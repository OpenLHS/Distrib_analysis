tkdestroy(popup)
}
on_cancel <- function() {
tclvalue(user_choice) <- "NULL"
tkdestroy(popup)
}
tkpack(tkbutton(popup, text = "Yes", command = on_true), side = "left", padx = 10)
tkpack(tkbutton(popup, text = "No", command = on_false), side = "left", padx = 10)
tkpack(tkbutton(popup, text = "Cancel", command = on_cancel), side = "left", padx = 10)
tkwait.window(popup)
result <- tclvalue(user_choice)
if(result=="NULL"){
stop("User need to specify if the privacy assessment on the response variable should be run or not.")
} else if(result=="TRUE"){
privacy = 1
} else {
privacy = 0
}
return(privacy)
}
# Ask user if we should run the privacy assessment on Y
privacy <- popup_window("Do you want to run the privacy assessment on the response variable?")
popup_window <- function(prompt){
popup <- tktoplevel()
tkwm.title(popup, "Choose an Option")
label <- tklabel(popup, text = prompt)
tkpack(label, padx = 20, pady = 10)
user_choice <- tclVar("")
on_true <- function() {
tclvalue(user_choice) <- "TRUE"
tkdestroy(popup)
}
on_false <- function() {
tclvalue(user_choice) <- "FALSE"
tkdestroy(popup)
}
on_cancel <- function() {
tclvalue(user_choice) <- "NULL"
tkdestroy(popup)
}
tkpack(tkbutton(popup, text = "Yes", command = on_true), side = "left", padx = 10)
tkpack(tkbutton(popup, text = "No", command = on_false), side = "left", padx = 10)
tkpack(tkbutton(popup, text = "Cancel", command = on_cancel), side = "left", padx = 10)
tkwait.window(popup)
result <- tclvalue(user_choice)
if(result=="NULL"){
stop("User need to specify if the privacy assessment on the response variable should be run or not.")
} else if(result=="TRUE"){
privacy = 1
} else {
privacy = 0
}
return(privacy)
}
# Ask user if we should run the privacy assessment on Y
privacy <- popup_window("Do you want to run the privacy assessment on the response variable?")
popup <- tktoplevel()
tkwm.title(popup, "Choose an Option")
label <- tklabel(popup, text = prompt)
tkpack(label, padx = 20, pady = 10)
user_choice <- tclVar("")
on_true <- function() {
tclvalue(user_choice) <- "TRUE"
tkdestroy(popup)
}
on_false <- function() {
tclvalue(user_choice) <- "FALSE"
tkdestroy(popup)
}
on_cancel <- function() {
tclvalue(user_choice) <- "NULL"
tkdestroy(popup)
}
tkpack(tkbutton(popup, text = "Yes", command = on_true), side = "left", padx = 10)
tkpack(tkbutton(popup, text = "No", command = on_false), side = "left", padx = 10)
tkpack(tkbutton(popup, text = "Cancel", command = on_cancel), side = "left", padx = 10)
tkwait.window(popup)
result <- tclvalue(user_choice)
popup_window <- function(prompt){
popup <- tktoplevel()
tkwm.title(popup, "Choose an Option")
label <- tklabel(popup, text = prompt)
tkpack(label, padx = 20, pady = 10)
user_choice <- tclVar("")
on_true <- function() {
tclvalue(user_choice) <- "TRUE"
tkdestroy(popup)
}
on_false <- function() {
tclvalue(user_choice) <- "FALSE"
tkdestroy(popup)
}
on_cancel <- function() {
tclvalue(user_choice) <- "NULL"
tkdestroy(popup)
}
tkpack(tkbutton(popup, text = "Yes", command = on_true), side = "left", padx = 10)
tkpack(tkbutton(popup, text = "No", command = on_false), side = "left", padx = 10)
tkpack(tkbutton(popup, text = "Cancel", command = on_cancel), side = "left", padx = 10)
tkwait.window(popup)
result <- tclvalue(user_choice)
if(result=="NULL" | result==""){
stop("User need to specify if the privacy assessment on the response variable should be run or not.")
} else if(result=="TRUE"){
privacy = 1
} else {
privacy = 0
}
return(privacy)
}
# Ask user if we should run the privacy assessment on Y
privacy <- popup_window("Do you want to run the privacy assessment on the response variable?")
############### Distributed inference ####################
############### Response-node code ###########################
## License: https://creativecommons.org/licenses/by-nc-sa/4.0/
## Copyright: GRIIS / Université de Sherbrooke
# Loading packages and setting up core variables --------------------------
# Currently, the automated node number allocation currently requires execution in R studio and rstudioapi package
# https://cran.r-project.org/package=rstudioapi
# If you want to skip the automated working directory setting, input 1 here.
# If you do so, make sure the working directory is set correctly manually.
manualwd <- -1
# If you want to manually set the parameter lambda, specify value here.
# If you do so, please refer to article to ensure adequate settings.
# Else, an automated value that complies with the assumptions of the method will be assigned.
lambda <- -1
# No modifications should be required below this point
###########################
popup_window <- function(prompt){
# Create pop up box
popup <- tktoplevel()
tkwm.title(popup, "Choose an Option")
label <- tklabel(popup, text = prompt)
tkpack(label, padx = 20, pady = 10)
user_choice <- tclVar("")
# Define how the user-response is registered
on_true <- function() {
tclvalue(user_choice) <- "TRUE"
tkdestroy(popup)
}
on_false <- function() {
tclvalue(user_choice) <- "FALSE"
tkdestroy(popup)
}
on_cancel <- function() {
tclvalue(user_choice) <- "NULL"
tkdestroy(popup)
}
# Define behavior of buttons
tkpack(tkbutton(popup, text = "Yes", command = on_true), side = "left", padx = 10)
tkpack(tkbutton(popup, text = "No", command = on_false), side = "left", padx = 10)
tkpack(tkbutton(popup, text = "Cancel", command = on_cancel), side = "left", padx = 10)
tkwait.window(popup)
result <- tclvalue(user_choice)
# Transorm user-response into the privacy assessment boolean
if(result=="NULL" | result==""){
stop("User need to specify if the privacy assessment on the response variable should be run or not.")
} else if(result=="TRUE"){
privacy = 1
} else {
privacy = 0
}
return(privacy)
}
if (manualwd != 1) {
# Set working directory automatically
# this.path package is available
if (require(this.path)) {
setwd(this.dir())
# else if running in R studio and the rstudioapi is available, set the correct working directory
} else if ((Sys.getenv("RSTUDIO") == "1") & (require("rstudioapi"))) {
print("RSTUDIO")
path <- dirname(rstudioapi::getActiveDocumentContext()$path)
setwd(path)
# no known means to automatically set working directory
} else {
stop("The required conditions to automatically set the working directory are not met. See R file")
}
} else {
print("The automated working directory setup has been bypassed. If there is an error, this might be the cause.")
}
# Ask user if we should run the privacy assessment on Y
privacy <- popup_window("Do you want to run the privacy assessment on the response variable?")
# Once the working directory as been set, save it so we can pass it to other files
path <- paste0(getwd(), "/")
# Verifying if there is a coordination node (response-node) data file present
nb_node1_files <- length(list.files(path=path, pattern="Data_node_1.csv"))
nb_node_output_files <- length(list.files(path=path, pattern="Data_node_[[:digit:]]+_init_output.rds"))
if (nb_node1_files==1 & nb_node_output_files>0) {
source("Response_node_init_iter_log-regV.R")
coord_log_reg(man_wd = manualwd, man_lambda = lambda, expath = path, privacy_switch = privacy)
} else {
stop("Node 1 data file missing or no output file from other nodes found")
}
setwd("~/GitHub/Elo_Propre/Distrib_analysis/Vertically_distributed_analysis/logistic_regression_nonpenalized/Logistic_regression_modelling/generic_code")
############### Distributed inference ####################
############### Covariate-node code ###########################
## License: https://creativecommons.org/licenses/by-nc-sa/4.0/
## Copyright: GRIIS / Université de Sherbrooke
# Loading packages and setting up core variables --------------------------
# Currently, the automated node number allocation currently requires execution in R studio and rstudioapi package
# https://cran.r-project.org/package=rstudioapi
# If you want to skip the automated working directory setting, input 1 here.
# If you do so, make sure the working directory is set correctly manualy.
manualwd <- -1
# If you want to override the node numbering based on filename, input 0 or a positive integer here
manualk <- 2
# No modifications should be required below this point
###########################
if (manualwd != 1) {
# Set working directory automatically
# this.path package is available
if (require(this.path)) {
setwd(this.dir())
# else if running in R studio and the rstudioapi is available, set the correct working directory
} else if ((Sys.getenv("RSTUDIO") == "1") & (require("rstudioapi"))) {
print("RSTUDIO")
path <- dirname(rstudioapi::getActiveDocumentContext()$path)
setwd(path)
# no known means to automatically set working directory
} else {
stop("The required conditions to automatically set the working directory are not met. See R file")
}
} else {
print("The automated working directory setup has been bypassed. If there is an error, this might be the cause.")
}
# Once the working directory as been set, save it so we can pass it to other files
path <- paste0(getwd(), "/")
# Veryfiying if there is a coordination node output file present
nbprimerfilesA <- length(list.files(pattern="Coord_node_primerA_for_data_node_[[:digit:]]+.csv"))
nbprimerfilesB <- length(list.files(pattern="Coord_node_primerB_for_data_node_[[:digit:]]+.rds"))
if (nbprimerfilesA == 1 & nbprimerfilesB == 1) {
source("Data_node_call_iter_log-regV.R")
data_call_iter_log_reg(manualwd,manualk,path)
} else if(nbprimerfilesA == 0 & nbprimerfilesB == 0) {
source("Data_node_call_init_log_regV.R")
data_call_init_log_reg(manualwd,manualk,path)} else {
stop("Primer files are missing or repeated.")
}
## Remove all environment variables.
## If you want to see the variable that were create, simply don't execute that line (and clear them manually after)
rm(list = ls())
############### Distributed inference ####################
############### Response-node code ###########################
## License: https://creativecommons.org/licenses/by-nc-sa/4.0/
## Copyright: GRIIS / Université de Sherbrooke
# Loading packages and setting up core variables --------------------------
# Currently, the automated node number allocation currently requires execution in R studio and rstudioapi package
# https://cran.r-project.org/package=rstudioapi
# If you want to skip the automated working directory setting, input 1 here.
# If you do so, make sure the working directory is set correctly manually.
manualwd <- -1
# If you want to manually set the parameter lambda, specify value here.
# If you do so, please refer to article to ensure adequate settings.
# Else, an automated value that complies with the assumptions of the method will be assigned.
lambda <- -1
# No modifications should be required below this point
###########################
popup_window <- function(prompt){
# Create pop up box
popup <- tktoplevel()
tkwm.title(popup, "Choose an Option")
label <- tklabel(popup, text = prompt)
tkpack(label, padx = 20, pady = 10)
user_choice <- tclVar("")
# Define how the user-response is registered
on_true <- function() {
tclvalue(user_choice) <- "TRUE"
tkdestroy(popup)
}
on_false <- function() {
tclvalue(user_choice) <- "FALSE"
tkdestroy(popup)
}
on_cancel <- function() {
tclvalue(user_choice) <- "NULL"
tkdestroy(popup)
}
# Define behavior of buttons
tkpack(tkbutton(popup, text = "Yes", command = on_true), side = "left", padx = 10)
tkpack(tkbutton(popup, text = "No", command = on_false), side = "left", padx = 10)
tkpack(tkbutton(popup, text = "Cancel", command = on_cancel), side = "left", padx = 10)
tkwait.window(popup)
result <- tclvalue(user_choice)
# Transorm user-response into the privacy assessment boolean
if(result=="NULL" | result==""){
stop("User need to specify if the privacy assessment on the response variable should be run or not.")
} else if(result=="TRUE"){
privacy = 1
} else {
privacy = 0
}
return(privacy)
}
if (manualwd != 1) {
# Set working directory automatically
# this.path package is available
if (require(this.path)) {
setwd(this.dir())
# else if running in R studio and the rstudioapi is available, set the correct working directory
} else if ((Sys.getenv("RSTUDIO") == "1") & (require("rstudioapi"))) {
print("RSTUDIO")
path <- dirname(rstudioapi::getActiveDocumentContext()$path)
setwd(path)
# no known means to automatically set working directory
} else {
stop("The required conditions to automatically set the working directory are not met. See R file")
}
} else {
print("The automated working directory setup has been bypassed. If there is an error, this might be the cause.")
}
# Ask user if we should run the privacy assessment on Y
privacy <- popup_window("Do you want to run the privacy assessment on the response variable?")
# Once the working directory as been set, save it so we can pass it to other files
path <- paste0(getwd(), "/")
# Verifying if there is a coordination node (response-node) data file present
nb_node1_files <- length(list.files(path=path, pattern="Data_node_1.csv"))
nb_node_output_files <- length(list.files(path=path, pattern="Data_node_[[:digit:]]+_init_output.rds"))
if (nb_node1_files==1 & nb_node_output_files>0) {
source("Response_node_init_iter_log-regV.R")
coord_log_reg(man_wd = manualwd, man_lambda = lambda, expath = path, privacy_switch = privacy)
} else {
stop("Node 1 data file missing or no output file from other nodes found")
}
## Remove all environment variables.
## If you want to see the variable that were create, simply don't execute that line (and clear them manually after)
rm(list = ls())
############### Distributed inference ####################
############### Response-node code ###########################
## License: https://creativecommons.org/licenses/by-nc-sa/4.0/
## Copyright: GRIIS / Université de Sherbrooke
# Loading packages and setting up core variables --------------------------
# Currently, the automated node number allocation currently requires execution in R studio and rstudioapi package
# https://cran.r-project.org/package=rstudioapi
# If you want to skip the automated working directory setting, input 1 here.
# If you do so, make sure the working directory is set correctly manually.
manualwd <- -1
# If you want to manually set the parameter lambda, specify value here.
# If you do so, please refer to article to ensure adequate settings.
# Else, an automated value that complies with the assumptions of the method will be assigned.
lambda <- -1
# No modifications should be required below this point
###########################
popup_window <- function(prompt){
# Create pop up box
popup <- tktoplevel()
tkwm.title(popup, "Choose an Option")
label <- tklabel(popup, text = prompt)
tkpack(label, padx = 20, pady = 10)
user_choice <- tclVar("")
# Define how the user-response is registered
on_true <- function() {
tclvalue(user_choice) <- "TRUE"
tkdestroy(popup)
}
on_false <- function() {
tclvalue(user_choice) <- "FALSE"
tkdestroy(popup)
}
on_cancel <- function() {
tclvalue(user_choice) <- "NULL"
tkdestroy(popup)
}
# Define behavior of buttons
tkpack(tkbutton(popup, text = "Yes", command = on_true), side = "left", padx = 10)
tkpack(tkbutton(popup, text = "No", command = on_false), side = "left", padx = 10)
tkpack(tkbutton(popup, text = "Cancel", command = on_cancel), side = "left", padx = 10)
tkwait.window(popup)
result <- tclvalue(user_choice)
# Transorm user-response into the privacy assessment boolean
if(result=="NULL" | result==""){
stop("User need to specify if the privacy assessment on the response variable should be run or not.")
} else if(result=="TRUE"){
privacy = 1
} else {
privacy = 0
}
return(privacy)
}
if (manualwd != 1) {
# Set working directory automatically
# this.path package is available
if (require(this.path)) {
setwd(this.dir())
# else if running in R studio and the rstudioapi is available, set the correct working directory
} else if ((Sys.getenv("RSTUDIO") == "1") & (require("rstudioapi"))) {
print("RSTUDIO")
path <- dirname(rstudioapi::getActiveDocumentContext()$path)
setwd(path)
# no known means to automatically set working directory
} else {
stop("The required conditions to automatically set the working directory are not met. See R file")
}
} else {
print("The automated working directory setup has been bypassed. If there is an error, this might be the cause.")
}
# Ask user if we should run the privacy assessment on Y
privacy <- popup_window("Do you want to run the privacy assessment on the response variable?")
############### Distributed inference ####################
############### Response-node code ###########################
## License: https://creativecommons.org/licenses/by-nc-sa/4.0/
## Copyright: GRIIS / Université de Sherbrooke
# Loading packages and setting up core variables --------------------------
# Currently, the automated node number allocation currently requires execution in R studio and rstudioapi package
# https://cran.r-project.org/package=rstudioapi
# If you want to skip the automated working directory setting, input 1 here.
# If you do so, make sure the working directory is set correctly manually.
manualwd <- -1
# If you want to manually set the parameter lambda, specify value here.
# If you do so, please refer to article to ensure adequate settings.
# Else, an automated value that complies with the assumptions of the method will be assigned.
lambda <- -1
# No modifications should be required below this point
###########################
popup_window <- function(prompt){
# Create pop up box
popup <- tktoplevel()
tkwm.title(popup, "Choose an Option")
label <- tklabel(popup, text = prompt)
tkpack(label, padx = 20, pady = 10)
user_choice <- tclVar("")
# Define how the user-response is registered
on_true <- function() {
tclvalue(user_choice) <- "TRUE"
tkdestroy(popup)
}
on_false <- function() {
tclvalue(user_choice) <- "FALSE"
tkdestroy(popup)
}
on_cancel <- function() {
tclvalue(user_choice) <- "NULL"
tkdestroy(popup)
}
# Define behavior of buttons
tkpack(tkbutton(popup, text = "Yes", command = on_true), side = "left", padx = 10)
tkpack(tkbutton(popup, text = "No", command = on_false), side = "left", padx = 10)
tkpack(tkbutton(popup, text = "Cancel", command = on_cancel), side = "left", padx = 10)
tkwait.window(popup)
result <- tclvalue(user_choice)
# Transorm user-response into the privacy assessment boolean
if(result=="NULL" | result==""){
stop("User need to specify if the privacy assessment on the response variable should be run or not.")
} else if(result=="TRUE"){
privacy = 1
} else {
privacy = 0
}
return(privacy)
}
if (manualwd != 1) {
# Set working directory automatically
# this.path package is available
if (require(this.path)) {
setwd(this.dir())
# else if running in R studio and the rstudioapi is available, set the correct working directory
} else if ((Sys.getenv("RSTUDIO") == "1") & (require("rstudioapi"))) {
print("RSTUDIO")
path <- dirname(rstudioapi::getActiveDocumentContext()$path)
setwd(path)
# no known means to automatically set working directory
} else {
stop("The required conditions to automatically set the working directory are not met. See R file")
}
} else {
print("The automated working directory setup has been bypassed. If there is an error, this might be the cause.")
}
# Ask user if we should run the privacy assessment on Y
privacy <- popup_window("Do you want to run the privacy assessment on the response variable?")
# Once the working directory as been set, save it so we can pass it to other files
path <- paste0(getwd(), "/")
# Verifying if there is a coordination node (response-node) data file present
nb_node1_files <- length(list.files(path=path, pattern="Data_node_1.csv"))
nb_node_output_files <- length(list.files(path=path, pattern="Data_node_[[:digit:]]+_init_output.rds"))
if (nb_node1_files==1 & nb_node_output_files>0) {
source("Response_node_init_iter_log-regV.R")
coord_log_reg(man_wd = manualwd, man_lambda = lambda, expath = path, privacy_switch = privacy)
} else {
stop("Node 1 data file missing or no output file from other nodes found")
}
## Remove all environment variables.
## If you want to see the variable that were create, simply don't execute that line (and clear them manually after)
rm(list = ls())
setwd("~/GitHub/Elo_Propre/Distrib_analysis/Vertically_distributed_analysis/logistic_regression_nonpenalized/Logistic_regression_modelling/examples/random_data_same_folder/distributed")
############### VERTICALLY DISTRIBUTED LOGISTIC REGRESSION ####################
## License: https://creativecommons.org/licenses/by-nc-sa/4.0/
## Copyright: GRIIS / Université de Sherbrooke
# Allow to set working directory automatically
library(this.path)
# If you want to manually set the parameter lambda, specify value here.
# If you do so, please refer to article to ensure adequate settings.
# Else, an automated value that complies with the assumptions of the method will be assigned.
lambda <- -1
# No modifications should be required below this point
######################################################
# Retrieve current working directory
setwd(this.dir())
examplefilepath <- paste0(getwd(), "/")
# Retrieve source code
setwd("../../example_handler")
source("Data_node_call_log-regV_ex.R")
source("Response_node_call_iter_log-regV_ex.R")
# Run covariate node code
vert_logistic_regression_example_datanode_handler(nodeid = 2, expath = examplefilepath)
# Run response node code
vert_logistic_regression_example_coordnode_handler(man_lambda = lambda, expath = examplefilepath)
# Run covariate node code for results
vert_logistic_regression_example_datanode_handler(nodeid = 2, expath = examplefilepath)
## Remove all environment variables.
## If you want to see the variable that were create, simply don't execute that line (and clear them manually after)
rm(list = ls())
setwd("~/GitHub/Elo_Propre/Distrib_analysis/Vertically_distributed_analysis/logistic_regression_nonpenalized/Logistic_regression_modelling/examples/random_data_same_folder/distributed")
